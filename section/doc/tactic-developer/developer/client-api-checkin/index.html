<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.8" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}


#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_checkin_checkout_operations">Checkin / Checkout Operations</h2>
<div class="sectionbody">
<div class="paragraph"><p><strong>Checking files in</strong></p></div>
<div class="paragraph"><p>The Client API has access to the full range of TACTIC&#8217;s asset management
system.</p></div>
<div class="paragraph"><p>Any sObject can become a "container" for check-ins. This has the
advantage that you can use this one SObject (container) to check in
files using the deep set of check-in tools provided by TACTIC. The rest
of this section describes the different types of check-ins available.</p></div>
<div class="paragraph"><p><strong>Simple Checkin</strong></p></div>
<div class="paragraph"><p>The simple_checkin() function allows you to check in a single file.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    file_path = "./test/miso_ramen.jpg"

    # now check in the file
    search_type = "unittest/person"
    code = "joe"
    context = "test_checkin"
    search_key = my.server.build_search_key(search_type, code)

    # simple check-in of a file.  No dependencies
    desc = 'A Simple Checkin'
    snapshot = my.server.simple_checkin(search_key, context, file_path, description=desc, mode="upload")
    print snapshot.get('snapshot')</code></pre>
</div></div>
<div class="paragraph"><p>The simple_checkin is the most basic type of check-in. It creates a
snapshot and then checks a file into that snapshot. The newly created
snapshot is returned.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;snapshot&gt;
  &lt;file name="miso_ramen_v001.jpg" type='main' code='123BAR'/&gt;
&lt;/snapshot&gt;</code></pre>
</div></div>
<div class="paragraph"><p>The exact file name that is checked in will vary depending on the
specific implemented naming conventions</p></div>
<div class="paragraph"><p><strong>Group (or Sequence) Checkin</strong></p></div>
<div class="paragraph"><p>The group_checkin() function allows you to check in a sequence of files,
defined by a frame range:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;start&gt;-&lt;end&gt;/&lt;by&gt;</code></pre>
</div></div>
<div class="paragraph"><p>For example, a frame range of 1 to 10 is descibed as "1-10". Or every
second frame from frame 20 to frame 50 can be described as "20-50/2".</p></div>
<div class="paragraph"><p>TACTIC provides two notations to describe the file names of a range of
frames. This special notation, in conjunction with the frame range, can
generate a sequence of files. The two notations are as follows:</p></div>
<div class="ulist"><ul>
<li>
<p>
&lt;base&gt;.##.&lt;ext&gt;
</p>
</li>
<li>
<p>
&lt;base&gt;.%0.4d.&lt;ext&gt;
</p>
</li>
</ul></div>
<div class="paragraph"><p>Here is a code example of checking in a sequence of files:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    pattern = "./test/miso_ramen.%0.4d.tif"
    file_range = '1-24'
    context = 'beauty '

    # build the search key
    search_type = "unittest/person"
    code = "joe"
    search_key = my.server.build_search_key(search_type, code)

    # simple checkin of a file
    desc = 'A Checkin of a group of files'
    context = "test_checkin"
    snapshot = server.group_checkin(search_key, context, file_pattern, file_range)
    print snapshot.get('snapshot')</code></pre>
</div></div>
<div class="paragraph"><p>When executed, this example will check in a sequence of 24 files
starting from 1 to 24. It should be noted that this method will by
default expect that the files have been uploaded to the server. For this
reason, it is often recommended to use preallocated check-ins for both
sequence and directory check-ins.</p></div>
<div class="paragraph"><p><strong>Directory Checkin</strong></p></div>
<div class="paragraph"><p>As the name suggests, a directory check-in enables an entire directory
and all of its subdirectories to be checked in. TACTIC does not keep
track of the contents of the checked-in directory. This allows you to
check in complex directory structures without having to inform TACTIC of
all of the details of the contents. This might be the best approach when
all the details of the directory are already handled by some other
system so it is not necessary for TACTIC to track things.</p></div>
<div class="paragraph"><p>Here is a code example of checking in a directory:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    file_path = "./test/XG002/beauty"

    # build the search key
    search_type = "unittest/person"
    code = "joe"
    search_key = my.server.build_search_key(search_type, code)
    context = "test_checkin"

    # simple check-in of a file.
    desc = 'A Simple Checkin'
    snapshot = my.server.directory_checkin(search_key, context, file_path, description=desc)
    print snapshot.get('snapshot')</code></pre>
</div></div>
<div class="paragraph"><p>Note that this code is very similar to single file check-ins (
simple_checkin() ), because TACTIC treats a directory check-in in a
similar manner to a file check-in. It uses the leaf directory as the
file name. It is important to consider naming conventions, because this
leaf directory will be handled using file naming conventions even though
it is a directory.</p></div>
<div class="paragraph"><p>As with group_checkin(), this method already expects the files to have
been uploaded to the server in the appropriate place. There are various
modes that can be used to alter the manner in which the files get to the
server repository. For details, see the "modes" section below.</p></div>
<div class="paragraph"><p><strong>Piecewise check-ins</strong></p></div>
<div class="paragraph"><p>TACTIC allows you to build up a check-in piecewise or stages. This is a
powerful feature because you can build a check-in over the course of
many operations (and many transactions if desired) and the whole set of
operations will be treated as a single versioned entity. The TACTIC
snapshot definition allows for the entry of multiple files into a single
check-in. Typically, the process begins by creating a new "empty"
snapshot. This snapshot is a placeholder which reserves a version and
context for a particular set of future operations. Once this empty
snapshot is created, you can start adding files and dependencies to it.</p></div>
<div class="paragraph"><p>The following example checks in a Maya file and a corresponding OBJ
file.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    maya_path = "./test/chr001/chr001_model.ma"
    obj_path = "./test/chr001/chr001_mode.obj"

    # build the search key
    search_type = "unittest/person"
    code = "joe"
    context = "test_checkin"
    search_key = my.server.build_search_key(search_type, code)

    # create an empty snapshot
    desc = 'A Piecewise Checkin'
    snapshot = my.server.create_snapshot(search_key, context, description=desc)
    print "empty"
    print snapshot.get('snapshot')

    snapshot_code = snapshot.get('code')
    snapshot = my.server.add_file(snapshot_code, maya_path, file_type='maya')
    snapshot = my.server.add_file(snapshot_code, obj_path, file_type='obj')
    print
    print "two files"
    print snapshot.get('snapshot')</code></pre>
</div></div>
<div class="paragraph"><p>Executing this code will result in the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>empty
&lt;snapshot/&gt;

two files
&lt;snapshot&gt;
  &lt;file name='chr001_model_v001.ma' file_code='1044BAR' type='maya'/&gt;
  &lt;file name='chr001_model_v001.obj' file_code='1045BAR' type='obj'/&gt;
&lt;/snapshot&gt;</code></pre>
</div></div>
<div class="paragraph"><p>First, an empty snapshot is created using create_snapshot(), then files
are added to this snapshot one by one. Note that the type here is
explicitly specified. This type differentiates one file in a snapshot
from another.</p></div>
<div class="paragraph"><p>It is also possible to add a sequence of files or even a directory to a
snapshot:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    pattern = "./test/miso_ramen.%0.4d.tif"
    file_range = '1-24'
    snapshot = server.add_group(snapshot_code, file_pattern, file_range, file_type='sequence')
    print snapshot.get('snapshot')

    directory = "./test/test_directory"
    snapshot = server.add_directory(snapshot_code, directory, file_type='directory')
    print snapshot.get('code')</code></pre>
</div></div>
<div class="paragraph"><p>Executing the last code snippet will give the following results:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;snapshot&gt;
  &lt;file name="mise_ramen.%0.4d.tif" file_code='1047BAR' type='sequence'/&gt;
&lt;/snapshot&gt;

&lt;snapshot&gt;
  &lt;file name="mise_ramen.%0.4d.tif" file_code='1047BAR' type='sequence'/&gt;
  &lt;file name="test_directory" file_code='1047BAR' type='directory'/&gt;
&lt;/snapshot&gt;</code></pre>
</div></div>
<div class="paragraph"><p><strong>Checkin Modes</strong></p></div>
<div class="paragraph"><p>There are various modes that you can use to check in files. These modes
determine how a file will be transferred to the repository.</p></div>
<div class="ulist"><ul>
<li>
<p>
upload: Uploads the files to a temporary directory
</p>
</li>
<li>
<p>
copy: Copies the files to the handoff directory
</p>
</li>
<li>
<p>
move: Moves the files to the handoff directory.
</p>
</li>
</ul></div>
<div class="paragraph"><p>The previous simple_checkin() example uses the "upload" mode. This means
that the client will connect to the server and use an HTTP connection to
upload the file to the server where it will be subsequently checked in.
HTTP does not require any additional setup and it may be the only choice
available for facilities having only WAN access to the TACTIC server.
However, HTTP is a very slow transport protocol so, if possible, it is
better and faster to use other available modes.</p></div>
<div class="paragraph"><p>The copy and move modes use a "handoff" directory, which is an
intermediate directory that is visible on the network to both the client
machine and the TACTIC server. When the check-in is executed, the files
are first copied or moved to this handoff directory. The TACTIC server
is then notified and grabs the files and puts them into the repository,
renaming as the naming conventions stipulate. The files are always
"moved" from the handoff directory to the repository. The advantage of
using these modes over the "upload" mode is that they go through NFS or
CIFS. These modes make use of the fast networks and huge file servers
that are available in typical media and production facilities.</p></div>
<div class="paragraph"><p>The copy and modes require a bit of setup because the server and the
client must be able to see the handoff directory. You need to configure
the TACTIC server configuration file, located in
&lt;site_dir&gt;/config/tactic_&lt;os&gt;-conf.xml. This file contains the following
relevant settings:</p></div>
<div class="ulist"><ul>
<li>
<p>
win32_client_handoff_dir: the handoff directory as seen from a Windows
client
</p>
</li>
<li>
<p>
linux_client_handoff_dir: the handoff directory as seen from a Linux
client
</p>
</li>
<li>
<p>
win32_server_handoff_dir: the handoff directory as seen from a Windows
TACTIC server
</p>
</li>
<li>
<p>
linux_server_handoff_dir: the handoff directory as seen from a Linux
server
</p>
</li>
</ul></div>
<div class="paragraph"><p>Note that the win32 settings apply to all flavors of Windows, including
Windows 64-bit machines. The Linux settings apply to all POSIX machines
including Debian base operating systems and Mac OS X.</p></div>
<div class="paragraph"><p>After you set the configuration, you can then use the copy or move modes
to take advantage of the handoff directory:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    # simple check-in of a file using move mode
    desc = 'A Simple Checkin'
    snapshot = my.server.simple_checkin(search_key, context, file_path, description=desc, mode="move")
    print snapshot.get('snapshot')</code></pre>
</div></div>
<div class="paragraph"><p>Note that the only difference in this example from earlier check-in
examples is that the mode parameter is set to "move".</p></div>
<div class="paragraph"><p><strong>Preallocated check-in (mode="preallocate")</strong></p></div>
<div class="paragraph"><p>Preallocated check-ins are the most efficient check-ins. Bandwidth and
storage space are expensive commodities in a typical media or production
facility, so there is a definite cost and time benefit to reducing their
use as much as possible.</p></div>
<div class="paragraph"><p>Preallocated check-ins enable a client process to be checked directly
into the repository. They are recommended for check-ins that are very
heavy in either bandwidth or disk usage and are designed to minimize
both. Some production processes that would benefit from using this
check-in mode include rendering frames, ingesting plates, simulating
data, and so on.</p></div>
<div class="paragraph"><p>The following steps describe the process for preallocating check-ins:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Create an empty snapshot to reserve a check-in version and context.
</p>
</li>
<li>
<p>
Ask for a path in the repository from the TACTIC server.
</p>
</li>
<li>
<p>
Create the files directly in the path given by the TACTIC server.
</p>
</li>
<li>
<p>
Inform TACTIC that the files have been placed in the appropriate
location.
</p>
</li>
</ol></div>
<div class="paragraph"><p>The path supplied by TACTIC in the preallocation is located directly in
the repository. The process generating the files can thus save the files
directly to the correct location in the repository (following all the
predefined naming conventions). Files are created directly in the
repository with the correct directory and file name as TACTIC would have
checked them in using the other methods. This eliminates later having to
copy or move files around the network unnecessarily, as is typically
required by other check-in modes.</p></div>
<div class="paragraph"><p>Because the simple_checkin(), group_checkin() and directory_checkin()
functions perform the entire check-in process in one step, you cannot
use them for preallocated check-ins. Instead, you would use a piecewise
check-in to build up the checked in parts. The following is an example
of a preallocated check-in using a piecewise approach:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>    search_type = "prod/render"
    code = "XG002_beauty"
    search_key = my.server.build_search_key(search_type, code)

    # create an empty snapshot
    desc = 'A Preallocated Checkin'
    context = "render"
    snapshot = my.server.create_snapshot(search_key, context, description=desc)

    # get the preallocated path
    snapshot_code = snapshot.get('code')
    file_pattern = snapshot.get_preallocated_path(snapshot_code, file_type="main")
    print "file_pattern: ", file_path

    # generate the files
    for i in range(1, 20):
        file_path = file_pattern % i
        render_file(file_path)

    # add the files to the snapshot
    snapshot = server.add_group(snapshot_code, file_type="main", file_range="1-20", mode="preallocate")
    print snapshot.get("snapshot")</code></pre>
</div></div>
<div class="paragraph"><p>Executing the above code would result in output something like:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>file_pattern: XG002_beauty_v012.%0.4d.tif
&lt;snapshot&gt;
  &lt;file name="XG002_beauty_v012.%0.4d.tif" file_code="123BAR" type="main"/&gt;
&lt;/snapshot&gt;</code></pre>
</div></div>
<div class="paragraph"><p>The file pattern returned is completely dependent on naming conventions.
In this case, the search_type would have had to define a naming
convention whereby the context of "render" produces the above file
pattern. For example, the file naming convention code could include:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>def prod_render(my):
    render = my.sobject
    ext = my.get_file_ext()

    parts = []
    parts.append( render.get_value('code') )
    parts.append( "v%0.3d" % my.snapshot.get_value("version")  )

    file_name = "_".join(parts) + ".%0.4d" + ext
    return file_name</code></pre>
</div></div>
<div class="paragraph"><p>(See the naming convention documentation for more information on how to
set up naming conventions.)</p></div>
<div class="paragraph"><p>It should be noted that the function get_preallocated_path() returns a
full path, including the filename as specified by the naming
conventions. Ideally, TACTIC must be able to generate the correct path
that can be used to save the files (as in the example above).</p></div>
<div class="paragraph"><p>There is enormous advantage to using preallocated check-ins. Files are
created directly to the repository, eliminating all of the unnecessary
copying of files around the servers. When groups of files reach the
muti-gigabyte or even terabyte range, it becomes prohibitively expensive
to check in files in the traditional manner. Preallocated check-ins
maximize the use of your internal system architecture.</p></div>
<div class="paragraph"><p><strong>In-Place Checkins</strong></p></div>
<div class="paragraph"><p>In general, the in-place check-in should be considered as the last
resort. In-place check-ins do not make use of the TACTIC naming
conventions, and may be the only option when you are confronted by a
legacy directory structure. Using this check-in method makes the
assumption that you will be able to later define logic that will map to
a desired naming convention. As a guideline, naming conventions should
be procedural and as simple as possible, so you must plan carefully
before considering in-place check-ins.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2015-10-22 21:52:39 EDT
</div>
</div>
</body>
</html>
